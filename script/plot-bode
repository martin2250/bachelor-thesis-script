#!/usr/bin/python3
import argparse
import time

import matplotlib.pyplot as plt
import numpy as np
import scipy.optimize
import scipy.signal

import lib.plotstyle
import lib.tekdecode

parser = argparse.ArgumentParser(
    description='generates bode plots from time-domain oscilloscope data')
parser.add_argument('chInput',
                    help='file that contains the amplifier input')
parser.add_argument('chOutput',
                    help='file that contains the amplifier output')
parser.add_argument('freq_start', type=float,
                    help='sweep start frequency')
parser.add_argument('freq_stop', type=float,
                    help='sweep stop frequency')
parser.add_argument('--sweep-type', choices=['rigol-log', 'linear'],
                    default='rigol-log', help='sweep type to estimate frequency')
parser.add_argument('--points', type=int, default=100, help='number of points')
parser.add_argument('--periods', type=float, default=3,
                    help='number of sine periods to use for each frequency')
parser.add_argument('--show_fits', action='store_true',
                    help='show fit for every point')
parser.add_argument('--invert', action='store_true',
                    help='invert output signal')
parser.add_argument('--stopwatch', action='store_true',
                    help='show time required for different operations')
parser.add_argument('--output',
                    help='plot output file')
parser.add_argument('--output_table',
                    help='table output file')


args = parser.parse_args()


def report_duration(event, start_time):
    if args.stopwatch:
        print(f'time spent in {event}: {time.time() - start_time:0.1f}s')


time_load_file_start = time.time()

voltage_in, sample_rate, length = lib.tekdecode.loadFile(args.chInput)
voltage_out, sample_rate_out, length_out = lib.tekdecode.loadFile(
    args.chOutput)

report_duration('load files', time_load_file_start)

if sample_rate != sample_rate_out:
    print('files have different sample rates')
    exit(1)

if length != length_out:
    print('files have different lengths')
    exit(1)

if args.invert:
    voltage_out = -voltage_out


def sine(t, amplitude, angular_frequency, phase, offset):
    return amplitude * np.sin(angular_frequency * t - phase) + offset


def fitsine(T, U, frequ_approx):
    try:
        downsample_factor = 1  # int(len(T) / 2000)

        if downsample_factor > 1:
            T = scipy.signal.decimate(T, downsample_factor, zero_phase=True)
            U = scipy.signal.decimate(U, downsample_factor, zero_phase=True)

        amplitude_max = np.max(np.abs(U)) or 0.01
        angular_frequency_approx = 2 * np.pi * freq_approx

        def sine_phase(t, phase):
            return amplitude_max * np.sin(angular_frequency_approx * t - phase)

        (phase_approx), _ = scipy.optimize.curve_fit(
            sine_phase, T, U, [0], bounds=([- np.pi], [np.pi]))

        # do proper fit
        guess = [amplitude_max, angular_frequency_approx, phase_approx, 0]
        bounds = (
            [amplitude_max * 0.7, angular_frequency_approx * 0.5, -np.pi, -0.1],
            [amplitude_max, angular_frequency_approx / 0.5, np.pi, 0.1])
        result, _ = scipy.optimize.curve_fit(sine, T, U, guess, bounds=bounds)

        amplitude, angular_frequency, phase, offset = result
        return amplitude, angular_frequency / (2 * np.pi), phase, offset
    except:
        return None


def approx_freq_rigol_log(sample_index):
    # see https://www.batronix.com/pdf/Rigol/UserGuide/DG1000Z_UserGuide_EN.pdf page 109
    P = 10**(np.log10(args.freq_stop / args.freq_start) / (length / sample_rate))
    T = (sample_index / sample_rate) + np.log10(args.freq_start) / np.log10(P)
    return P**T


def approx_freq_linear(sample_index):
    return args.freq_start + (args.freq_stop - args.freq_start) * (sample_index / length)


approx_freq = {'rigol-log': approx_freq_rigol_log,
               'linear': approx_freq_linear}[args.sweep_type]


def get_slice_length(frequency):
    return int(args.periods * sample_rate / frequency)


# output arrays
F = []
A = []
Phi = []

for index_center in np.linspace(get_slice_length(args.freq_start), length - get_slice_length(args.freq_stop), args.points).astype(int):
    freq_approx = approx_freq(index_center)
    slice_length = get_slice_length(freq_approx)

    index_start = index_center - int(slice_length / 2)
    index_end = index_start + slice_length

    T = np.arange(0, slice_length) / sample_rate
    U_in = voltage_in[index_start: index_end]
    U_out = voltage_out[index_start: index_end]

    result_in = fitsine(
        T, U_in, freq_approx)
    result_out = fitsine(
        T, U_out, freq_approx)

    if result_in is None or result_out is None:
        continue

    F.append(result_in[1])
    A.append(result_out[0] / result_in[0])

    phi = result_in[2] - result_out[2]
    if phi < -np.pi:
        phi += 2 * np.pi
    if phi > np.pi:
        phi -= 2 * np.pi
    Phi.append(phi)

    if args.show_fits:
        def plot_curve(U, result, color):
            amplitude, frequency, phase, offset = result

            plt.plot(T, U, '+', color=color,
                     label=f'input, fit:\nf: {frequency:0.1f} Hz\nA: {amplitude:0.3f} Vpp')
            plt.plot(T, sine(T, amplitude, frequency
                             * 2 * np.pi, phase, offset), color= 'black')

        plot_curve(U_in, result_in, 'C1')
        plot_curve(U_out, result_out, 'C2')

        plt.legend(loc=1)
        plt.show()


axis = plt.gca()
axis2 = axis.twinx()
axis2.set_ylim(-np.pi / 2, np.pi / 2)

ln_gain = axis.plot(F, A, '+', label='gain', color='C1')
ln_phase = axis2.plot(F, Phi, '+', label='phase', color='C2')

axis.grid(which='both')
axis.set_xscale("log", nonposx='clip')
axis.set_yscale("log", nonposy='clip')

lns = ln_gain + ln_phase
labs = [l.get_label() for l in lns]
axis.legend(lns, labs, loc=0)

if args.output_table:
    with open(args.output_table, 'w') as file:
        file.write('# frequency (Hz), gain (V/V), phase (rad)')
        for (f, g, phi) in zip(F, A, Phi):
            file.write(f'{f:0.1f}\t{g:0.3e}\t{phi:0.2f}\n')

if args.output:
    plt.savefig(args.output)
else:
    plt.show()
