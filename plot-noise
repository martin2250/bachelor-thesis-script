#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
import argparse

import argcomplete

parser = argparse.ArgumentParser(
	description='generates power density plots from time-domain oscilloscope data')
parser.add_argument('--trace', nargs='+', type=str, action='append', required=True,
                    help='label and files for a trace, can be used multiple times')

parser.add_argument('--gain-fit',
                    help='supply a (frequency - gain) file to calculate input noise from output noise')
parser.add_argument('--factor', type=float,
                    help='constant factor to multiply on noise')

parser.add_argument('--resolution', type=int,
                    help='fft resolution', default=100000)
parser.add_argument('--title', type=str,
                    help='plot title')
parser.add_argument('--reference', type=str, default='out',
                    help='input or output referenced')
parser.add_argument('--output', type=str,
                    help='output file')

argcomplete.autocomplete(parser)
args = parser.parse_args()

if True:
	import os
	from dataclasses import dataclass
	from multiprocessing import Pool

	import matplotlib.pyplot as plt
	import numpy as np
	import scipy.signal

	import lib.fitgain
	import lib.plotstyle
	import lib.tekdecode


def process_file(file):
	voltage, sample_rate, length = lib.tekdecode.loadFile(file)

	frequency, power = scipy.signal.welch(
		voltage, sample_rate, nperseg=args.resolution)

	return power, frequency, sample_rate


def main():
	titles = []		# trace titles
	file_mappings = []  # indeces of files for each trace
	files = []		# flattened array of all files

	for trace in args.trace:
		if not os.path.exists(trace[0]):
			titles.append(trace[0])
			trace = trace[1:]
		else:
			titles.append(','.join(trace))

		file_mappings.append(np.arange(len(files), len(files) + len(trace)))
		files += trace

	print(titles)
	print(file_mappings)
	print(files)

	pool = Pool()
	output = pool.map(process_file, files)
	pool.close()
	pool.join()

	power, frequency, sample_rate = zip(*output)
	frequency = frequency[0]
	power = np.array(power)

	if sample_rate.count(sample_rate[0]) != len(sample_rate):
		print('files have different saple rates!')
		exit(1)

	ax = plt.gca()

	for (title, file_mapping) in zip(titles, file_mappings):
		print(file_mapping)
		power_mean = np.mean(power[file_mapping], axis=0)
		voltage = np.sqrt(power_mean)

		if args.factor:
			voltage *= args.factor
		if args.gain_fit:
			(frequency_fit, gain) = np.loadtxt(
				args.gain_fit, unpack=True, usecols=(0, 1))
			gain_fitfunc = lib.fitgain.fit(frequency_fit, gain)
			voltage /= gain_fitfunc(frequency)

		ax.plot(frequency, voltage * 1e6, label=title)

	ax.set_xscale("log", nonposx='clip')
	ax.set_yscale("log", nonposy='clip')
	ax.grid(which='both')
	for subax in [ax.xaxis, ax.yaxis]:
		subax.set_major_formatter(matplotlib.ticker.FormatStrFormatter('%g'))
	ax.set_ylabel('$\\sqrt{J_{ss}^{%s}(f)}$ (ÂµV)' % args.reference)
	ax.set_xlabel('$f$ (Hz)')
	ax.legend()
	ax.set_title('noise density')
	plt.legend()

	if args.output:
		plt.savefig(args.output)
	else:
		plt.show()


if __name__ == "__main__":
	main()
