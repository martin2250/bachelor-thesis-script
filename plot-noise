#!/usr/bin/python3
import argparse
import os
from dataclasses import dataclass
from multiprocessing import Pool

import matplotlib.pyplot as plt
import numpy as np
import scipy.signal

import lib.plotstyle
import lib.tekdecode

parser = argparse.ArgumentParser(
	description='generates power density plots from time-domain oscilloscope data')
parser.add_argument('--trace', nargs='+', type=str, action='append', required=True,
                    help='label and files for a trace, can be used multiple times')
parser.add_argument('--resolution', type=int,
                    help='fft resolution', default=100000)
parser.add_argument('--output', type=str,
                    help='output file')
parser.add_argument('--title', type=str,
                    help='plot title')

args = parser.parse_args()


def process_file(file):
	voltage, sample_rate, length = lib.tekdecode.loadFile(file)

	frequency, power = scipy.signal.welch(
		voltage, sample_rate, nperseg=args.resolution)

	return power, frequency, sample_rate


def main():
	titles = []		# trace titles
	file_mappings = []  # indeces of files for each trace
	files = []		# flattened array of all files

	for trace in args.trace:
		if not os.path.exists(trace[0]):
			titles.append(trace[0])
			trace = trace[1:]
		else:
			titles.append(','.join(trace))

		file_mappings.append(np.arange(len(files), len(files) + len(trace)))
		files += trace

	print(titles)
	print(file_mappings)
	print(files)

	pool = Pool()
	output = pool.map(process_file, files)
	pool.close()
	pool.join()

	power, frequency, sample_rate = zip(*output)
	frequency = frequency[0]
	power = np.array(power)

	if sample_rate.count(sample_rate[0]) != len(sample_rate):
		print('files have different saple rates!')
		exit(1)

	ax = plt.gca()

	for (title, file_mapping) in zip(titles, file_mappings):
		print(file_mapping)
		power_mean = np.mean(power[file_mapping], axis=0)
		voltage = np.sqrt(power_mean)

		ax.plot(frequency, voltage * 1e6, label=title)

	lib.plotstyle.format_fft_plot(ax)
	ax.set_title('noise density')
	plt.legend()

	if args.output:
		plt.savefig(args.output)
	else:
		plt.show()


if __name__ == "__main__":
	main()
