#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
import argparse

import argcomplete

print('still have to complete this turd')
exit(1)

parser = argparse.ArgumentParser(
	description='generates bode plots from time-domain oscilloscope data')

parser.add_argument('output',
                    help='output file, tab separated')
parser.add_argument('scope_data_input', metavar='scope-data-input',
                    help='file that contains the amplifier input')
parser.add_argument('scope_data_output', metavar='scope-data-output',
                    help='file that contains the amplifier output')
parser.add_argument('freq_start', metavar='freq-start', type=float,
                    help='sweep start frequency')
parser.add_argument('freq_stop', metavar='freq-stop', type=float,
                    help='sweep stop frequency')

parser.add_argument('--sweep-type', choices=['rigol-log', 'linear'],
                    default='rigol-log',
                    help='sweep type to estimate frequency')
parser.add_argument('--points', type=int, default=100,
                    help='number of points')
parser.add_argument('--periods', type=float, default=3,
                    help='number of sine periods to use for each frequency')
parser.add_argument('--show-fits', action='store_true',
                    help='show fit for every point')
parser.add_argument('--invert', action='store_true',
                    help='invert output signal')

parser.add_argument('--stopwatch', action='store_true',
                    help='show time required for different operations')

################################################################################

argcomplete.autocomplete(parser)
args = parser.parse_args()

# prevent autopep8 from moving these imports to the front
if True:
	import time
	from dataclasses import dataclass
	from multiprocessing import Pool

	import numpy as np
	import scipy.optimize
	import scipy.signal

	import lib.tekdecode

################################################################################

time_start = time.time()


def report_duration(event):
	global time_start
	if args.stopwatch:
		print(f'time spent {event}: {time.time() - time_start:0.1f}s')
	time_start = time.time()

################################################################################


voltage_in, sample_rate, length = lib.tekdecode.loadFile(
	args.scope_data_input)
voltage_out, sample_rate_out, length_out = lib.tekdecode.loadFile(
	args.scope_data_output)

report_duration('loading files')

############################################################################

if sample_rate != sample_rate_out:
	print('files have different sample rates')
	exit(1)

if length != length_out:
	print('files have different lengths')
	exit(1)

if args.invert:
	voltage_out = -voltage_out
	report_duration('inverting output channel')

############################################################################


@dataclass
class FitResult:
	frequency: float
	amplitude: float
	phase: float
	offset: float
	time: np.array
	voltage: np.array


def sine(t, amplitude, angular_frequency, phase, offset):
	return amplitude * np.sin(angular_frequency * t - phase) + offset


def fitsine(T, U, freq_approx):
	try:
		downsample_factor = 1  # int(len(T) / 2000)

		if downsample_factor > 1:
			T = scipy.signal.decimate(T, downsample_factor, zero_phase=True)
			U = scipy.signal.decimate(U, downsample_factor, zero_phase=True)

		amplitude_max = np.max(np.abs(U)) or 0.01
		angular_frequency_approx = 2 * np.pi * freq_approx
		offset_mean = np.mean(U)

		def sine_phase(t, phase):
			return amplitude_max * np.sin(angular_frequency_approx * t - phase) + offset_mean

		(phase_approx), _ = scipy.optimize.curve_fit(
			sine_phase, T, U, [0], bounds=([- np.pi], [np.pi]))

		# do proper fit
		guess = [amplitude_max, angular_frequency_approx, phase_approx, offset_mean]
		bounds = (
			[amplitude_max * 0.7, angular_frequency_approx * 0.5, -np.pi, -amplitude_max],
			[amplitude_max, angular_frequency_approx / 0.5, np.pi, amplitude_max])
		result, _ = scipy.optimize.curve_fit(sine, T, U, guess, bounds=bounds)

		amplitude, angular_frequency, phase, offset = result

		return FitResult(amplitude=amplitude, frequency=angular_frequency / (2 * np.pi), phase=phase, offset=offset, time=T, voltage=U)
	except Exception as e:
		return None

############################################################################


def approx_freq_rigol_log(sample_index):
	# see https://www.batronix.com/pdf/Rigol/UserGuide/DG1000Z_UserGuide_EN.pdf page 109
	P = 10**(np.log10(args.freq_stop / args.freq_start) / (length / sample_rate))
	T = (sample_index / sample_rate) + np.log10(args.freq_start) / np.log10(P)
	return P**T


def approx_freq_linear(sample_index):
	return args.freq_start + (args.freq_stop - args.freq_start) * (sample_index / length)


approx_freq = {'rigol-log': approx_freq_rigol_log,
               'linear': approx_freq_linear}[args.sweep_type]

############################################################################


def get_slice_length(frequency):
	return int(args.periods * sample_rate / frequency)

############################################################################


def center_index_to_results(index_center):
	freq_approx = approx_freq(index_center)
	slice_length = get_slice_length(freq_approx)

	index_start = index_center - int(slice_length / 2)
	index_end = index_start + slice_length

	T = np.arange(0, slice_length) / sample_rate
	U_in = voltage_in[index_start: index_end]
	U_out = voltage_out[index_start: index_end]

	result_in = fitsine(
		T, U_in, freq_approx)
	result_out = fitsine(
		T, U_out, freq_approx)

	return result_in, result_out

############################################################################


center_indexes = np.linspace(get_slice_length(
        args.freq_start), length - get_slice_length(args.freq_stop), args.points).astype(int)

center_indexes = np.extract(approx_freq(
	center_indexes) < args.max_freq, center_indexes)

pool = Pool()
results = pool.map(center_index_to_results, list(center_indexes))
pool.close()
pool.join()

report_duration('fitting sine to data')

############################################################################

# output arrays
Frequency = []
Gain = []
Phase = []

for (result_in, result_out) in results:
	if result_in is None or result_out is None:
		continue

	phi = result_in.phase - result_out.phase
	if phi < -np.pi:
		phi += 2 * np.pi
	if phi > np.pi:
		phi -= 2 * np.pi

	Frequency.append(result_in.frequency)
	Gain.append(result_out.amplitude / result_in.amplitude)
	Phase.append(phi)

	if args.show_fits:
		def plot_curve(result, color, label):
			plt.plot(result.time, result.voltage, '+', color=color,
                            label=f'{label}, fit:\nf: {result.frequency:0.1f} Hz\nA: {result.amplitude:0.3f} Vpp')
			plt.plot(result.time, sine(result.time, result.amplitude, result.frequency *
                                2 * np.pi, result.phase, result.offset), color= 'black')

		plot_curve(result_in, 'C0', 'input')
		plot_curve(result_out, 'C1', 'output')

		plt.legend(loc=1)
		plt.show()

Frequency = np.array(Frequency)
Gain = np.array(Gain)
Phase = np.array(Phase)

report_duration('creating final output values')

################################################################################

condition = Frequency < args.max_freq
Frequency = np.extract(condition, Frequency)
Gain = np.extract(condition, Gain)
Phase = np.extract(condition, Phase)

################################################################################

print(f'final data points: {len(Frequency)}')

################################################################################

if args.output_table:
	with open(args.output_table, 'w') as file:
		file.write('# frequency (Hz), gain (V/V), phase (rad)')
		for (f, g, phi) in zip(Frequency, Gain, Phase):
			file.write(f'{f:0.1f}\t{g:0.3e}\t{phi:0.2f}\n')

			report_duration('writing values to table')

################################################################################

if args.fit_gain:
	def lowpass(f, gain, cutoff, order):
		return gain / np.power(np.abs(1 + 1j * f / cutoff), order)

	(gain, cutoff, order), _ = scipy.optimize.curve_fit(lowpass, Frequency,
	                                                    Gain, (10, 10000, 1), bounds=([0, 100, 0.5], [100, 1e6, 1000]))

	Frequency_fit = np.linspace(np.min(Frequency), np.max(Frequency), 100)
	Gain_fit = lowpass(Frequency_fit, gain, cutoff, order)
	print(f'gain: {gain:0.2f}  ({20*np.log10(gain):0.1f} dB)')
	print(f'cutoff: {cutoff:0.1f} Hz')
	print(f'order: {order:0.2f}')

################################################################################

axis_gain = plt.gca()
axis_gain.grid(which='both')
axis_gain.set_xscale("log", nonposx='clip')
axis_gain.set_xlabel('frequency (Hz)')

if args.gain_axis == 'dB':
	axis_gain.set_ylabel('gain (dB)')
	Gain_plot = 20 * np.log10(Gain)
	if args.fit_gain:
		Gain_fit_plot = 20 * np.log10(Gain_fit)
	axis_gain.plot([np.min(Frequency), np.max(Frequency)], [-3, -3], color='red')

elif args.gain_axis == 'ratio':
	axis_gain.set_ylabel('gain')
	axis_gain.set_yscale("log", nonposy='clip')
	Gain_plot = Gain
	if args.fit_gain:
		Gain_fit_plot = Gain_fit

line_gain = axis_gain.plot(Frequency, Gain_plot, '+', label='gain', color='C1')
if args.fit_gain:
	line_gain_fit = axis_gain.plot(
		Frequency_fit, Gain_fit_plot, '-', label='gain fit', color='C0')

################################################################################

axis_phase = axis_gain.twinx()
axis_phase.set_ylabel('phase')

if args.phase_axis == 'rad':
	axis_phase.set_ylim(-np.pi, np.pi)
	Phase_plot = Phase

elif args.phase_axis == 'deg':
	axis_phase.set_ylim(-180, 180)
	axis_phase.set_yticks(np.arange(-180, 181, 45, ))
	Phase_plot = Phase * 180 / np.pi

line_phase = axis_phase.plot(
	Frequency, Phase_plot, '+', label='phase', color='C2')

################################################################################

lns = line_gain + line_phase
labs = [l.get_label() for l in lns]
axis_gain.legend(lns, labs, loc=0)

if args.title:
	plt.title(args.title)
elif args.input_type == 'table':
	plt.title(args.data_file)
else:
	plt.title(args.scope_data_input)

################################################################################

report_duration('generating plot')

if args.output:
	plt.savefig(args.output)
else:
	plt.show()
